# Задание "bayan"

## Условие
Пользуясь имеющимися в библиотеке Boost структурами и алгоритмами
разработать утилиту для обнаружения файлов-дубликатов.
Утилита должна иметь возможность через параметры командной строки
указывать

• директории для сканирования (может быть несколько)

• директории для исключения из сканирования (может быть несколько)

• уровень сканирования (один на все директории, 0 - только указанная
директория без вложенных)

• минимальный размер файла, по умолчанию проверяются все файлы
больше 1 байта.

• маски имен файлов разрешенных для сравнения (не зависят от
регистра)

• размер блока, которым производится чтения файлов, в задании этот
размер упоминается как S

• один из имеющихся алгоритмов хэширования (crc32, md5 -
конкретные варианты определить самостоятельно), в задании
эта функция упоминается как H

## Результат работ
Должен быть список полных путей файлов
с идентичным содержимым, выводимый на стандартный вывод. На одной
строке один файл. Идентичные файлы должны подряд, одной группой.
Разные группы разделяются пустой строкой.
Обязательно свойство утилиты - бережное обращение с дисковым вводом
выводом. Каждый файл может быть представлен в виде списка блоков
размера S. Если размер файла не кратен, он дополняется бинарными
нулями.
Файл world.txt из одной строки
Hello, World\n
При размере блока в 5 байт, будет представлен как
Hello
, Wor
ld\n\0\0
Каждый блок должен быть свернут выбранной функцией хэширования.
Возможные коллизии игнорируются. Из предположения, что
H("Hello") == A
H(", Wor") == B
H("ld\n\0\0") == C
1
Наш файл world.txt может быть представлен в виде последовательности
ABC
Рассмотрим второй файл cpp.txt
Hello, C++\n
Который после хэширования блоков
H("Hello") == A
H(", C++") == D
H("\n\0\0\0\0") == E
может быть представлен в виде последовательности ADE
Порядок сравнения этих файлов должен быть максимально бережным. То
есть обработка первого файла world.txt вообще не приводит к чтению с
диска, ведь нам еще не с чем сравнивать. Как только мы добираемся до
файла cpp.txt только в этот момент происходит перое чтение первого блока
обоих файлов. В данном случае блоки идентичны, и необходимо прочесть
вторые блоки, которые уже различаются. Файлы различны, оставшиеся
данные не читаются.
Файлы считаются идентичными при полном совпадении последовательности
хешей блоков.

## Самоконтроль

 • блок файла читается с диска не более одного раза
 
 • блок файла читается только в случае необходимости
 
 • не забыть, что дубликатов может быть больше чем два
 
 • описание параметров в файле README.md корне репозитория

## Проверка
Задание считается выполнено успешно, если после просмотра кода,
подключения репозитория, установки пакета и запуска бинарного файла
командой (параметры из описания):
$ bayan [...]
будут обнаружены файлы-дубликаты, без ложных срабатываний и
пропуска существующих дубликатов.
Количество прочитанных данных с диска минимально.

## Выбранные комманды для использования утилиты

Комманды

 - `-d` directories for scan
 - `-ds` directories for skip
 - `-l 1` or `-l 0`
    - 0 means only current directory (default value)
    - 1 mean scan subdirectories too
 - `-s` min file size
 - `-m` file names mask (как поняла значения словосочетания "маски файлов" так и сделала ;-) )
 - `-x` extension of desired files 
 - `-e` extension of skipped files
 - `-n` size of read block
 - `-hs` hash function
 - `-w` или `-u` используется для прямого указания системы в которой запускается утилита
По идее оно должно определять делиметер для директорий автоматически но на всякий случай пусть будет
При указании обоих комманд будет браться первая(? ну это не точно я ещё не решила)

Использование тега `-d` является обязательным (пока что, мож потом изменю этот факт)

Использование тега `-x` обозначает список конкретных раширений для проверки и бессмысленно использовать с ним `-e`
Хотя к ошибке такой синтаксис привести не должен
К тому же, по идее если написать (не знаю зачем кому-то так писать, но just in case) `-x pdf txt doc docx -e txt`
файлы с расширением `.txt` не будут включены в поиск, сканирование, сравнение, ибо нечего злоупотреблять моим терпением)))

Использование тега `-l 0` ПОКА бесполезно ибо по умолчанию без указания -l оно будет сканировать только данную директорию, без вложенных (життя бентежне)
В принципе потом можно замутить такую штуку чтоб типа -l можно было указывать для каждой директории в списке на сканирование, но пока так (типа туду)

Размеры `-s` и `-n` указываются в байтах (!поле для размышлений)



Пути, имена сабдиректорий и маски указываются строго в `" "` иначе маски и скиппед сабдиректории просто отбрасываются
Имя директории без кавычек берется до первого пробела (по идее, надо проверить реализовала ли я эту штуку в итоге или только подумала)

### Маски файлов

`start_name*` выберет все файлы начинающиеся со `start_name` 
например `start_name_of_some_video.mp4` или `start_name_of_book.pdf`


`*contains_simbols*` выберет все файлы в имени которых содержится `*contains_simbols*`
например `contains_simbols_vidosik.mkv` или `other_contains_simbols_text.txt` или `selfie_contains_simbols_image.png`

`*final_simbols` тут я решила подразвлечься и выбрать все файлы заканчивающиеся на данные символы не учитывая
расширения и "присваиваний повторения" (типа когда качаешь файл и потом ещё такой же файл к нему добавляется (1) или (2) или (1)(1))

Маска файла без указания звездочки будет искатся "ас ит ис" с любым экстеншеном и присвоенным повторением


### Hash функции

Поддерживаемые хеш алгоритмы:
 - md5
 - sha1
 - sha224
 - sha256
 - sha384
 - sha512

Все операции хеширования благополучно позаимствованы с сайта http://www.zedwood.com/
Изобретать велосипед пол беды, а вот колесо - то уже через чур)))

Если в качестве алгоритма вводится что-то не из списка, хеш производится через md5 (как это правильно сказать-то??? через? с помощью? используя?)

Я использовала криптофункции патамуша уже выдохлась) эта часть немного "лишняя" для меня в этом задании
Та поняла я, что криптографические функции немного не для того, но так уже и будет

### Примеры использования комманд

Пример:

`./file_double_triple_founder -d "D:\\arm_courses" -s "D:\\arm_courses\\start_hardware" -l 1 -s 10 -x pdf -n 10`

в итоге будут просканированны все файлы в папке `D:\\arm_courses` и её вложенных папках, если таковые имеются, 
но будет пропущена папка "D:\\arm_courses\\start_hardware" (опять таки, если таковая имеется, объявление несуществующих папок/подпапок не должно приводить к ошибкеб но в любом случае будет замедлять работу надо подумать над этим будет)
минимальных размер рассматриваемых файлов будет 10 байт (`empty.pdf` с размером 1байт будет пропущен)
для сканирования будут взяты только `pdf` файлы
блок для сравнения будет составлять 10байт

Тут кстати надо подумать над суразностью комбинации минимального размера файла и блока для чтения *хммм думающий смайлик*

Ещё пример:

`./file_double_triple_founder -d "D:\\arm_courses\\arm_course_start" -fx "arm_embed_transcript*" -e mp4 -w`

В результате будут просканированны все файлы, начинающиеся на `arm_embed_transcript` 
в папке `D:\\arm_courses\\arm_course_start`
только в самой папке, вложенные директории будут пропущены, если таковые имеются
видеофайлы с раширением `mp4` сканироватся не будут
во внимание будут браться файлы размером от 1байта, так как минимальнй размер файла указан не был
Данные из файлов так же будут читаться по одному байту так как "кусок для чтения" указан не был
(Хотя тут тоже как бы надо подумать какой кусок для чтения оптимальный и брать его если нет явного указания)

Указывать минимальный размер файла в 0 байт не запрещено законом
Указание минусового значения будет просто отбрасывать знак (по идее)

Указывать директориИ для сканирования и директориИ для исключений можно по нескольку
Директории для исключения (по идее) могут быть как полным путем так и просто именем папки
(в итоге надо проверить не забыла ли я реализовать эту мини-фичу)

## Прояснения
Я решила сначала пройтись по всем директориям и составить список файлов с их расширениями и размером

Дальше "подозреваемыми" на повторяшек становятся только файлы с одинаковым расширением и размером.
Далее внутри этих группок, названных мною "линиями" (типа как "линии кеша" только не так в итоге получилось),
делаем само чтение, сравнение и отбрасование из "линии" после каждой итерации прочтения.
